<?php

require_once("includes/jpgraph/src/jpgraph.php");

/** 
 * The skeleton for this class was autogenerated by Propel  on:
 *
 * [08/16/06 22:43:13]
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package mer 
 */
class GraphModel extends BaseGraphModel {

	public $labelFont = FF_FONT1;

	public $labelStyleFont = FS_BOLD;

	public $labelStyleSize = 11;

  /**
   * Elimina todas las preguntas de los ejes de un grafico.
   *
   */
	function deleteAxes() {
		$crit = new Criteria();
		$crit->add(GraphModelAxisPeer::GRAPHID, $this->getId());
		GraphModelAxisPeer::doDelete($crit);
	}
	
	function getTypeAxis($axis) {
		switch ($axis) {
			case "x": $type = $this->getTypeX();
								break;
			case "y": $type = $this->getTypeY();
								break;
			case "z": $type = $this->getTypeZ();
								break;
		}
		return $type;
	}

	function isOptionsAxis($axis) {
		$type = $this->getTypeAxis($axis);
		if ($type == 0) {
    	$questions = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,$type);
			$question = QuestionPeer::get($questions[0]);
			if ( $question && $question->getType() == QUESTION_TYPE_OPTIONS )
				return true;
		}
		return false;
	}
	
	function getScaleOptionsAxis($axis) {
		$questions = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,0);
		$question = QuestionPeer::get($questions[0]);
		$options = $question->getOptions();
		$min = 0;
		$max = 0;
		$i = 0;
		foreach ($options as $option) {
			if ( $i == 0 ) {
				$min = $option->getValue();
				$max = $option->getValue();
				$labelMin = $option->getText();
				$labelMax = $option->getText();
			}
			else {
				if ( $option->getValue() > $max ) {
					$max = $option->getValue();
					$labelMax = $option->getText();
				}
				if ( $option->getValue() < $min ) {
					$min = $option->getValue();
					$labelMin = $option->getText();
				}
			}
			$i++;
		}
		$minmax = array("min" => $min, "max" => $max, "labelMin" => $labelMin, "labelMax" => $labelMax);
		return $minmax;
	}

	function getValueAxis($axis,$actor) {
		$type = $this->getTypeAxis($axis);
		$result = 0;
		switch ($type) {
			case 0:
      	//valor unico
				$questions = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,$type);
				$answer = AnswerPeer::getAnswerByActorAndQuestion($actor,$questions[0]);
				if (!empty($answer))
	     		$result = $answer->getAnswer();
     		break;
     	case 1:
     		//cociente de valores
				$questionsNum = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,2);
				$questionsDen = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,3);
				$resultNum = 0;
				$resultDen = 0;
				foreach ($questionsNum as $question) {
		    	$answer = AnswerPeer::getAnswerByActorAndQuestion($actor,$question);
					$resultNum += $answer->getAnswer();
				}
				foreach ($questionsDen as $question) {
		    	$answer = AnswerPeer::getAnswerByActorAndQuestion($actor,$question);
					$resultDen += $answer->getAnswer();
				}
				$result = $resultNum / $resultDen;
				break;
			case 4:
				//mayor
				$initialized = false;
        $questions = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,$type);
				foreach ($questions as $question) {
    			$answer = AnswerPeer::getAnswerByActorAndQuestion($actor,$question);
    			if (!$initialized)
    				$result = $answer->getAnswer();
    			else
    				if ( $answer->getAnswer() > $result )
    					$result = $answer->getAnswer();
    		}
    		break;
    	case 5:
    		//menor
				$initialized = false;
        $questions = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,$type);
				foreach ($questions as $question) {
    			$answer = AnswerPeer::getAnswerByActorAndQuestion($actor,$question);
    			if (!$initialized)
    				$result = $answer->getAnswer();
    			else
    				if ( $answer->getAnswer() < $result )
    					$result = $answer->getAnswer();
    		}
    		break;
    	case 6:
    	case 7:
    		//promedio o suma
        $questions = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,$type);
				$counter = 0;
				$resultSum = 0;
				foreach ($questions as $question) {
    			$answer = AnswerPeer::getAnswerByActorAndQuestion($actor,$question);
   				$resultSum += $answer->getAnswer();
   				$counter++;
    		}
    		if ($type == 6)
					$result = $resultSum / $counter;
				else
					$result = $resultSum;
    		break;
    	case 10:
    		//Valores de pie o infography
    		$result = array();
        $questions = GraphModelAxisPeer::getQuestionIdsByGraphIdAndAxisAndType($this->getId(),$axis,$type);
        $resultQuestions = array();
        $resultAnswers = array();
				foreach ($questions as $question) {
    			$answer = AnswerPeer::getAnswerByActorAndQuestion($actor,$question);
    			$thisQuestion = QuestionPeer::get($question);
    			if ($thisQuestion)
	    			$resultQuestions[] = $thisQuestion->getQuestion();
	    		if ($answer)
	    			$resultAnswers[] = $answer->getAnswer();
    		}
    		$result["questions"] = $resultQuestions;
    		$result["answers"] = $resultAnswers;
		}
		return $result;
	}
	
	function getGraphPie($actor) {
		  $questions = $this->getValueAxis("x",$actor->getId());

			require_once("includes/jpgraph/src/jpgraph_pie.php");
			require_once("includes/jpgraph/src/jpgraph_pie3d.php");
			require_once("includes/jpgraph/src/jpgraph_canvas.php");

			$data = $questions["answers"];
			
			$graph = new PieGraph(520,320,"auto");
			$graph->SetShadow();
			
			$graph->title->Set($this->getName());
			$graph->title->SetFont(FF_VERDANA,FS_BOLD);
			
			$p1 = new PiePlot3D($data);
			$p1->SetSize(0.5);
			$p1->SetCenter(0.45);
			$p1->SetLegends($questions["questions"]);
			$p1->value->SetFont(FF_VERDANA,FS_NORMAL,8);

			$graph->legend->SetFont(FF_VERDANA,FS_NORMAL,9);

			$graph->Add($p1);
			
			return $graph;
	}
	
	function getGraphInfography($actor) {
		  $questions = $this->getValueAxis("x",$actor->getId());

			require_once("includes/jpgraph/src/jpgraph_canvas.php");

			$data = $questions["answers"];
			
			$graph = new CanvasGraph(520,320,'auto' );
			$graph->SetShadow();
			
			$graph->title->Set($this->getName());
			$graph->title->SetFont(FF_VERDANA,FS_BOLD);
			
 			$graph->SetBackgroundImage("images/clear.gif",BGIMG_CENTER);

			$graph->SetMargin( 6,11,2 ,11);
			$graph->SetMarginColor( 'navy' );
			$graph->InitFrame();

			$posY = 50;
			for ($i=0;$i<count($data);$i++) {
				// Create and add a new text
				$txt=new Text($questions["questions"][$i].": ".$data[$i],20,$posY);
				$txt->SetFont(FF_VERDANA,FS_BOLD,8);
				$txt->SetBox('ivory','navy','gray');
				$txt->SetColor('navy');
				$graph->AddText($txt);
				$posY += 40;
			}

			return $graph;
	}
	
	function getGraphDataActor($actor) {

		$x = $this->getValueAxis("x",$actor->getId());
		$y = $this->getValueAxis("y",$actor->getId());
		//$z = $this->getValueAxis("z",$actor->getId());
		$z = 3;

		$datax = array(floatval($x));
    $datay = array(floatval($y));
		$dataz = array(floatval($z));
		$labels = array($actor->getName());
		return array("datax" => $datax, "datay" => $datay, "dataz" => $dataz, "labels" => $labels);
	}
	
	function getGraphDataCategory($category) {
		$principalActors = ActorPeer::getPrincipalActors($category->getId());
		$datax = array();
		$datay = array();
		$dataz2 = array();
		$labels = array();
		foreach ($principalActors as $actor) {
			$x = $this->getValueAxis("x",$actor->getId());
			$y = $this->getValueAxis("y",$actor->getId());
			$z = $this->getValueAxis("z",$actor->getId());

			$datax[] = floatval($x);
        $datay[] = floatval($y);
			$dataz2[] = floatval($z);
			$labels[] = $actor->getName();
		}
		$dataz = array();
		$maxz = max($dataz2);
		$minz = min($dataz2);
		$paso = ($maxz-$minz)/5;
		for ($i=0; $i<count($dataz2); $i++) {
			$dataz[] = floatval($dataz2[$i]/$paso);
		}
		return array("datax" => $datax, "datay" => $datay, "dataz" => $dataz, "labels" => $labels);
	}
	
	function makeMark($width) {
	 		$mark = new PlotMark();
			$mark->setType(MARK_FILLEDCIRCLE);
			$mark->setWidth($width);
			$mark->SetColor(array(235,235,235));
			return $mark;
	}

	function getGraphPlot($actor,$category=null) {
	                                             	
		require_once("includes/RealBalloonLabelPlot.php");

	  if ($this->getActors() == 1)
			$graphData = $this->getGraphDataActor($actor);
		else
      $graphData = $this->getGraphDataCategory($category);
      
    $datax = $graphData["datax"];
    $datay = $graphData["datay"];
    $dataz = $graphData["dataz"];
    $labels = $graphData["labels"];

		if ( $this->isOptionsAxis("x") )
			$minmax["x"] = $this->getScaleOptionsAxis("x");
		else
			$minmax["x"] = array("min" => min($datax), "max" => max($datax));

		if ( $this->isOptionsAxis("y") )
			$minmax["y"] = $this->getScaleOptionsAxis("y");
		else
			$minmax["y"] = array("min" => min($datay), "max" => max($datay));

      if ( $this->isOptionsAxis("x") ) {
			$minx = $minmax["x"]["min"];
			$maxx = $minmax["x"]["max"];
		}
		if ( $this->isOptionsAxis("y") ) {
			$miny = $minmax["y"]["min"];
  			$maxy = $minmax["y"]["max"];
  		}

		$graph = new Graph(520,320,"auto");
		$graph->SetScale("linlin",$miny,$maxy,$minx,$maxx);

		$graph->xaxis->title->SetFont(FF_VERDANA,FS_NORMAL,10);
		$graph->yaxis->title->SetFont(FF_VERDANA,FS_NORMAL,10);
		$graph->xaxis->SetLabelAlign('right','center');
		$graph->yaxis->SetLabelAlign('center','bottom');

		$graph->xaxis->scale->ticks->SupressMinorTickMarks('true');
		$graph->yaxis->scale->ticks->SupressMinorTickMarks('true');
		$graph->xaxis->scale->ticks->SetSide(SIDE_BOTTOM);
		$graph->yaxis->scale->ticks->SetSide(SIDE_LEFT);

 		if ( $this->isOptionsAxis("y") ) {
			if (($minmax["y"]["max"]>0 && $minmax["y"]["min"]>0) || ($minmax["y"]["max"]<=0 && $minmax["y"]["min"]<=0))
      	$nada = 0;
      else
				$graph->xaxis->SetPos(($minmax["y"]["max"]+$minmax["y"]["min"])/2);
		}

		if ( $this->isOptionsAxis("x") ) {
			if (($minmax["x"]["max"]>0 && $minmax["x"]["min"]>0) || ($minmax["x"]["max"]<=0 && $minmax["x"]["min"]<=0))
      	$nada = 0;
  	  else
				$graph->yaxis->SetPos(($minmax["x"]["max"]+$minmax["x"]["min"])/2);
		}

		function FCallback($xVal,$yVal,$zVal) {
			// This callback will adjust the fill color and size of
			// the datapoint according to the data value according to
  		return array($zVal*4,"","");
		}

		$graph->img->SetMargin(50,130,20,40);
		$graph->SetShadow();

		//$graph->title->Set("Real Balloon Plot");
		$graph->title->SetFont(FF_VERDANA,FS_BOLD,11);

		$graph->xaxis->SetTitle($this->getLabelX(),'high');
		$graph->yaxis->SetTitle($this->getLabelY(),'high');

		$graph->xaxis->SetFont(FF_VERDANA,FS_NORMAL,8);
		$graph->yaxis->SetFont(FF_VERDANA,FS_NORMAL,8);

		$sp1 = new RealBalloonLabelPlot($datay,$datax,$dataz,$labels);
		$sp1->mark->SetType(MARK_FILLEDCIRCLE);
		$sp1->mark->SetFillColor("red");
		$sp1->mark->SetWidth(8);
//		$sp1->setLabelFont($this->labelFont,$this->labelFontStyle,$this->labelFontSize);
		$sp1->setLabelFont(FF_VERDANA,FS_NORMAL,8);

		// Specify the callback
		$sp1->mark->SetCallbackXYZ("FCallback");

		$graph->Add($sp1);

 		$mark = new PlotMark();
		$mark->setType(MARK_FILLEDCIRCLE);
		$mark->setWidth(0.01);
		$graph->legend->add($this->getLabelZ(),"red",$mark);
    if ( $this->isOptionsAxis("z") ) {
    	$scale = $this->getScaleOptionsAxis("z");
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add($scale["labelMin"],"red",$this->makeMark(4));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(13));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add($scale["labelMax"],"red",$this->makeMark(20));
			$graph->legend->SetMarkAbsVSize(18);
    }
    else {
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(4));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add((max($dataz)-min($dataz))/2,"red",$this->makeMark(13));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(0.05));
			$graph->legend->add("","red",$this->makeMark(20));
			$graph->legend->SetMarkAbsVSize(16);
		}
		$graph->legend->balloon = true;
		$graph->legend->SetMarkAbsHSize(0);
		$graph->legend->SetFont(FF_VERDANA,FS_NORMAL,8);
		$graph->legend->SetPos(0.04,0.45,'right','center'); 

		return $graph;
	}
	
	function getGraph($actor,$category=null) {

		switch ($this->getType()) {
			case "pie": return $this->getGraphPie($actor);
			case "infography": return $this->getGraphInfography($actor);
			case "plot":
			case "plot_bubble":	
			default: return $this->getGraphPlot($actor,$category);
		}
		return false;
	}

}
