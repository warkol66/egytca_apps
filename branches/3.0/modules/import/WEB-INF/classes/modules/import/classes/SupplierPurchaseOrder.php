<?php

require_once 'import/classes/SupplierPurchaseOrderItem.php';
require_once 'import/classes/SupplierPurchaseOrderItemPeer.php';
require_once 'import/classes/SupplierPurchaseOrderHistory.php';
require_once 'import/classes/SupplierPurchaseOrderHistoryPeer.php';
require_once 'import/classes/om/BaseSupplierPurchaseOrder.php';


/**
 * Skeleton subclass for representing a row from the 'import_supplierPurchaseOrder' table.
 *
 * Orden de Pedido a Proveedor
 *
 * This class was autogenerated by Propel on:
 *
 * Mon Feb  2 17:24:15 2009
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    anmaga
 */
class SupplierPurchaseOrder extends BaseSupplierPurchaseOrder {
	
	const STATUS_FABRICATION_NON_INITIATED = 1;
	const STATUS_FABRICATION_ON_TIME = 2;
	const STATUS_FABRICATION_DELAYED = 3;
	const STATUS_FABRICATION_STOPPED = 4;
	const STATUS_WAITING_FOR_TRANSPORT = 5;
	
	//nombre de los estados para los clientes
	private $statusNames = array(
								SupplierPurchaseOrder::STATUS_FABRICATION_NON_INITIATED => 'Fabrication requested',
								SupplierPurchaseOrder::STATUS_FABRICATION_ON_TIME => 'On-Time',
								SupplierPurchaseOrder::STATUS_FABRICATION_DELAYED => 'Delayed',
								SupplierPurchaseOrder::STATUS_FABRICATION_STOPPED => 'Stopped',
								SupplierPurchaseOrder::STATUS_WAITING_FOR_TRANSPORT => 'Waiting for Transport'																											
							);
	
	/**
	 * Saves the current status of the instance in his history
	 * @return boolean
	 */
	public function saveCurrentStatusOnHistory($comment='') {
		
		require_once('SupplierPurchaseOrderHistory.php');
		
		try {

			$supplierPurchaseOrderHistory = new SupplierPurchaseOrderHistory();
			$supplierPurchaseOrderHistory->setSupplierPurchaseOrder($this);
			$supplierPurchaseOrderHistory->setStatus($this->getStatus());
			$supplierPurchaseOrderHistory->setCreatedAt(time());
			if (!empty($comment)) {
				$supplierPurchaseOrderHistory->setComments($comment);
			}
			$supplierPurchaseOrderHistory->save();
			
		} catch (Exception $e) {
			return false;
		}
		
		return true;
	}

	/**
	 * Devuelve un array con los nombres de los distintos mensajes de status para el adminstrador
	 * @return array
	 */
	public function getStatusNames() {
		return $this->statusNames;
	}	


	/**
	 * Devuelve el nombre del status actual de la cotizacion para un administrador
	 * @return string
	 */
	public function getStatusName() {
		return $this->statusNames[$this->getStatus()];
	}
	
	
	/**
	 * Realiza un seguimiento sobre la orden de compra a proveedor
	 * 
	 * @param $status integer Codigo de Status
	 * @param $comment string Comentario sobre cambio de estado
	 * @return boolean
	 */
	public function performTracking($status,$comment) {
		
		try {
			
			$this->setStatus($status);
			$this->save();
			$this->saveCurrentStatusOnHistory($comment);
			
		} catch (PropelException $e) {
			return false;
		}
		
		return true;
		
	}
	
	/**
	 * Indica si la orden esta en alguno de los estados posibles de fabricacion
	 *
	 * @return boolean
	 */
	public function isOnFabrication() {
		$status = $this->getStatus();
		$result = ($status == SupplierPurchaseOrder::STATUS_FABRICATION_NON_INITIATED || $status == SupplierPurchaseOrder::STATUS_FABRICATION_ON_TIME || $status == SupplierPurchaseOrder::STATUS_FABRICATION_DELAYED || $status == SupplierPurchaseOrder::STATUS_FABRICATION_STOPPED);
		return $result;
	}

	/**
	 * Devuelve un array asociativo con la cantidad de containers recomendada
	 * de cada tipo para toda la carga de la orden.
	 */
	public function getContainersQuantityAssoc() {
		global $system;
		$items = $this->getSupplierPurchaseOrderItems();
		$containers = $system["config"]["import"]["containers"];
		$totalContainersQuantity = array($containers['container1']['type'] => 0, $containers['container2']['type'] => 0);
		foreach ($items as $item) {
			$recommendedContainer = $item->getRecommendedContainer();
			$recommendedContainerType = $recommendedContainer['type'];
			$recommendedContainersQuantity = $item->getRecommendedContainersQuantity();
			$totalContainersQuantity[$recommendedContainerType] += $recommendedContainersQuantity;
		}
		return $totalContainersQuantity;
	}
	
	/**
	 * Obtiene la fecha en que la orden paso al estado de waiting for transport
	 * a partir de su información histórica.
	 */
	public function getFabricationDate() {
		return SupplierPurchaseOrderHistoryQuery::create()->filterBySupplierPurchaseOrder($this)
														  ->filterByStatus(SupplierPurchaseOrder::STATUS_WAITING_FOR_TRANSPORT)
														  ->orderBy('Createdat', 'desc')  //Nos aseguramos que de como resultado el más actual.
														  ->select('Createdat')
														  ->findOne();
	}
	
	/**
	 * Indica si una orden está a la espera de transporte.
	 * 
	 * Solo en este estado pueden ser iniciados los tramites de embarque y
	 * nacionalización.
	 * 
	 * @return verdadero si existe al menos un SupplierPurchaseOrderHistory
	 * perteneciente a esta orden cuyo estado sea STATUS_WAITING_FOR_TRANSPORT.
	 */
	public function isWaitingForTransport() {
		return SupplierPurchaseOrderHistoryQuery::create()->filterBySupplierPurchaseOrder($this)
														  ->filterByStatus(SupplierPurchaseOrder::STATUS_WAITING_FOR_TRANSPORT)
														  ->count() > 0;
	}
	
	public function hasShipment() {
		return ShipmentQuery::create()->filterBySupplierPurchaseOrder($this)->count() > 0;
	}

} // SupplierPurchaseOrder
