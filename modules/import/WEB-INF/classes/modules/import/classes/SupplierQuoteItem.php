<?php

require_once 'import/classes/SupplierQuoteItemCommentPeer.php';
require_once 'import/classes/om/BaseSupplierQuoteItem.php';


/**
 * Skeleton subclass for representing a row from the 'import_supplierQuoteItem' table.
 *
 * Elemento de Cotizacion de Proveedor
 *
 * This class was autogenerated by Propel on:
 *
 * Mon Feb  2 17:02:11 2009
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    anmaga
 */
class SupplierQuoteItem extends BaseSupplierQuoteItem {

	const STATUS_NEW = 1;
	const STATUS_QUOTED = 2;
	const STATUS_FEEDBACK = 3;
	
	private $statusNames = array(
								SupplierQuoteItem::STATUS_NEW => 'New',
								SupplierQuoteItem::STATUS_QUOTED => 'Quoted',
								SupplierQuoteItem::STATUS_FEEDBACK => 'Feedback'								
							);

	private $containers;
							
	const PACKAGE_BY_UNIT = 1;
	const PACKAGE_BY_CARTON = 2;
	
	function __construct() {
		parent::__construct();
		global $system;
		$this->containers = $system["config"]["import"]["containers"];
	}
	
	/**
	 * Calcula el volumen en m3 segun la informacion ingresada en la cotizacion sobre la unidad
	 * @return float
	 */
	public function getUnitVolume() {
		return ($this->getUnitWidth() * $this->getUnitHeight() * $this->getUnitLength() / 1000000);
	}

	/**
	 * Calcula el volumen en m3 segun la informacion ingresada en la cotizacion sobre el bulto
	 * @return float
	 */	
	public function getCartonVolume() {
		return ($this->getCartonWidth() * $this->getCartonHeight() * $this->getCartonLength() / 1000000);		
	}
	
	/**
	 * Calcula la densidad segun la informacion ingresada en la cotizacion sobre la unidad
	 */
	function getUnitDensity() {
		
		if ($this->getUnitVolume() == 0)
			return 0;
		
		return ($this->getUnitGrossWeigth() / $this->getUnitVolume());
	}
	
	/**
	 * Calcula la densidad segun la informacion ingresada en la cotizacion sobre la unidad
	 */
	function getCartonDensity() {

		if ($this->getCartonVolume() == 0)
			return 0;
		
		return ($this->getCartonGrossWeigth() / $this->getCartonVolume());

	}
	
	/**
	 * Calcula el volumen segun la informacion ingresada en la cotizacion sobre el bulto
	 * @return float
	 */	
	public function getTotalVolume() {
		return ($this->getUnitVolume() * $this->getQuantity());		
	}

	/**
	 * Calcula el volumen segun la informacion ingresada en la cotizacion sobre el bulto
	 * @return float
	 */	
	public function getTotalWeigth() {
		return ($this->getUnitGrossWeigth() * $this->getQuantity());		
	}

	/**
	 * Devuelve el nombre del status actual del item de la cotizacion
	 * @return string
	 */
	public function getStatusName() {
		return $this->statusNames[$this->getStatus()];
	}

	/**
	 * Indica si la cotizacion del item se encuentra en estado nuevo
	 * @return boolean
	 */
	public function isNew() {
		return ($this->getStatus() == SupplierQuoteItem::STATUS_NEW);
	}
	
	/**
	 * Indica si la cotizacion del item se encuentra contestada
	 * @return boolean
	 */
	public function isQuoted() {
		return ($this->getStatus() == SupplierQuoteItem::STATUS_QUOTED);
	}
	
	/**
	 * Indica si la cotizacion del item se encuentra en espera de respuesta por negociacion
	 * @return boolean
	 */
	public function isOnFeedback() {
		return ($this->getStatus() == SupplierQuoteItem::STATUS_FEEDBACK);
	}
	
	/**
	 * Realiza una peticion de Feedback sobre un item
	 * @param $user User instancia de usuario que pide el feedback
	 * @param $comment String comentario del usuario que pide el feedback donde indica la razon del mismo
	 */
	public function askFeedback($user,$comment) {
		
		try {

			$this->setStatus(SupplierQuoteITem::STATUS_FEEDBACK);

			require_once('SupplierQuoteItemCommentPeer.php');
			//creamos el comentario relacionado a la actualizacion
			$commentParams = array();
			$commentParams['supplierQuoteItemComment']['price'] = $this->getPrice();
			$commentParams['supplierQuoteItemComment']['delivery'] = $this->getDelivery();
			$commentParams['supplierQuoteItemComment']['comments'] = $comment;
			$commentParams['supplierQuoteItemComment']['userId'] = $user->getId();

			$comment = SupplierQuoteItemCommentPeer::createComment($commentParams['supplierQuoteItemComment']);
			$this->addSupplierQuoteItemComment($comment);

			$this->save();

			//actualizamos el estado general de la cotizacion
			$supplierQuote = $this->getSupplierQuote();

			if (!$supplierQuote->isOnFeedback()) {
				$supplierQuote->setStatus(SupplierQuote::STATUS_FEEDBACK);
				$supplierQuote->save();
				$supplierQuote->saveCurrentStatusOnHistory();
			}
	
		} catch (PropelException $e) {
			return false;
		}
		
	}

	/**
	 * Obtiene la ultimo item de cotizacion de proveedor similar al actual, de tal
	 * forma de permitir en la vista, rellenar campos que el proveedor ya haya ingresado.
	 * @return SupplierQuoteItem
	 */
	public function getLastSupplierQuoteItemRelated() {
		
		$supplierQuote = $this->getSupplierQuote();
		
		$criteria = new Criteria();
		$criteria->addJoin(SupplierQuoteItemPeer::SUPPLIERQUOTEID,SupplierQuotePeer::ID,Criteria::INNER_JOIN);
		$criteria->add(SupplierQuotePeer::SUPPLIERID,$supplierQuote->getSupplierId());
		$criteria->add(SupplierQuoteItemPeer::PRODUCTID,$this->getProductId());
		//solo se consideran items que hayan sido cotizados
		$criteria->add(SupplierQuoteItemPeer::STATUS,SupplierQuoteItem::STATUS_QUOTED);
		$criteria->addDescendingOrderByColumn(SupplierQuoteItemPeer::ID);
		$criteria->setLimit(1);
		
		$result = SupplierQuoteItemPeer::doSelect($criteria);
		return $result[0];
		
	}
	
	/**
	 * Obtiene el producto relacionado de la cotizacion.
	 * @return Product Product Instance
	 */
	public function getProduct() {
		$criteria = new Criteria();
		
		$criteria->add(ProductPeer::ID,$this->getProductId());
		$criteria->setLimit(1);
		
		$result = ProductPeer::doSelect($criteria);
		return $result[0];
	}

	/**
	 * Obtiene el producto relacionado de la cotizacion que fue reemplazado si fue el caso
	 * @return Product Product Instance
	 */	
	public function getReplacedProduct() {

		$criteria = new Criteria();

		$criteria->add(ProductPeer::ID,$this->getReplacedProductId());
		$criteria->setLimit(1);

		$result = ProductPeer::doSelect($criteria);
		return $result[0];
	}
	
	/**
	 * Indica si el producto del item ha sido reemplazado por el proveedor
	 * @return Boolean
	 */
	public function hasProductBeingReplaced() {
		$replacedProduct = $this->getReplacedProduct();
		return (!empty($replacedProduct));
	}
	
	/**
	 * Devuelve la densidad unitaria si no es 0, en caso contrario devuelve
	 * la densidad por bulto.
	 */
	public function getDensity() {
		$density = $this->getUnitDensity();
		if ($density != 0)
			return $density;
		return $this->getCartonDensity();
	}
	
	/**
	 * Devuelve un array asociativo teniendo type, weightCap y volumeCap.
	 */
	public function getRecommendedContainer() {
		$density = $this->getDensity();
		if ($density > $this->containers['densityThreshold'])
			return $this->containers['container1'];
		return $this->containers['container2'];
	}
	
	public function getRecommendedContainersQuantityByWeight() {
		$container = $this->getRecommendedContainer();
		$weigthCap = $container['weightCap'];
		$totalWeigth = $this->getTotalWeigth();
		return $totalWeigth / $weigthCap;
	}
	
	public function getRecommendedContainersQuantityByVolume() {
		$container = $this->getRecommendedContainer();
		$volumeCap = $container['volumeCap'];
		$totalVolume = $this->getTotalVolume();
		return $totalVolume / $volumeCap;
	}
	
	public function getRecommendedContainersQuantity() {
		return max($this->getRecommendedContainersQuantityByWeight(), $this->getRecommendedContainersQuantityByVolume());
	}

} // SupplierQuoteItem
